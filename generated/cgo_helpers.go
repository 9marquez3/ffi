// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../ffi.pc
#include "../ffi.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFilBLSSignatureMemory allocates memory for type C.fil_BLSSignature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSSignatureValue = unsafe.Sizeof([1]C.fil_BLSSignature{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSSignature) Ref() *C.fil_BLSSignature {
	if x == nil {
		return nil
	}
	return x.refa2ac09ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSSignature) Free() {
	if x != nil && x.allocsa2ac09ba != nil {
		x.allocsa2ac09ba.(*cgoAllocMap).Free()
		x.refa2ac09ba = nil
	}
}

// NewFilBLSSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSSignatureRef(ref unsafe.Pointer) *FilBLSSignature {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSSignature)
	obj.refa2ac09ba = (*C.fil_BLSSignature)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSSignature) PassRef() (*C.fil_BLSSignature, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa2ac09ba != nil {
		return x.refa2ac09ba, nil
	}
	mema2ac09ba := allocFilBLSSignatureMemory(1)
	refa2ac09ba := (*C.fil_BLSSignature)(mema2ac09ba)
	allocsa2ac09ba := new(cgoAllocMap)
	allocsa2ac09ba.Add(mema2ac09ba)

	var cinner_allocs *cgoAllocMap
	refa2ac09ba.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocsa2ac09ba.Borrow(cinner_allocs)

	x.refa2ac09ba = refa2ac09ba
	x.allocsa2ac09ba = allocsa2ac09ba
	return refa2ac09ba, allocsa2ac09ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSSignature) PassValue() (C.fil_BLSSignature, *cgoAllocMap) {
	if x.refa2ac09ba != nil {
		return *x.refa2ac09ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSSignature) Deref() {
	if x.refa2ac09ba == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.refa2ac09ba.inner))
}

// allocFilAggregateResponseMemory allocates memory for type C.fil_AggregateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilAggregateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilAggregateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilAggregateResponseValue = unsafe.Sizeof([1]C.fil_AggregateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregateResponse) Ref() *C.fil_AggregateResponse {
	if x == nil {
		return nil
	}
	return x.refb3efa36d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregateResponse) Free() {
	if x != nil && x.allocsb3efa36d != nil {
		x.allocsb3efa36d.(*cgoAllocMap).Free()
		x.refb3efa36d = nil
	}
}

// NewFilAggregateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregateResponseRef(ref unsafe.Pointer) *FilAggregateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilAggregateResponse)
	obj.refb3efa36d = (*C.fil_AggregateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregateResponse) PassRef() (*C.fil_AggregateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3efa36d != nil {
		return x.refb3efa36d, nil
	}
	memb3efa36d := allocFilAggregateResponseMemory(1)
	refb3efa36d := (*C.fil_AggregateResponse)(memb3efa36d)
	allocsb3efa36d := new(cgoAllocMap)
	allocsb3efa36d.Add(memb3efa36d)

	var csignature_allocs *cgoAllocMap
	refb3efa36d.signature, csignature_allocs = x.Signature.PassValue()
	allocsb3efa36d.Borrow(csignature_allocs)

	x.refb3efa36d = refb3efa36d
	x.allocsb3efa36d = allocsb3efa36d
	return refb3efa36d, allocsb3efa36d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregateResponse) PassValue() (C.fil_AggregateResponse, *cgoAllocMap) {
	if x.refb3efa36d != nil {
		return *x.refb3efa36d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregateResponse) Deref() {
	if x.refb3efa36d == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refb3efa36d.signature))
}

// allocFilZeroSignatureResponseMemory allocates memory for type C.fil_ZeroSignatureResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilZeroSignatureResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilZeroSignatureResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilZeroSignatureResponseValue = unsafe.Sizeof([1]C.fil_ZeroSignatureResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilZeroSignatureResponse) Ref() *C.fil_ZeroSignatureResponse {
	if x == nil {
		return nil
	}
	return x.ref835a0405
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilZeroSignatureResponse) Free() {
	if x != nil && x.allocs835a0405 != nil {
		x.allocs835a0405.(*cgoAllocMap).Free()
		x.ref835a0405 = nil
	}
}

// NewFilZeroSignatureResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilZeroSignatureResponseRef(ref unsafe.Pointer) *FilZeroSignatureResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilZeroSignatureResponse)
	obj.ref835a0405 = (*C.fil_ZeroSignatureResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilZeroSignatureResponse) PassRef() (*C.fil_ZeroSignatureResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref835a0405 != nil {
		return x.ref835a0405, nil
	}
	mem835a0405 := allocFilZeroSignatureResponseMemory(1)
	ref835a0405 := (*C.fil_ZeroSignatureResponse)(mem835a0405)
	allocs835a0405 := new(cgoAllocMap)
	allocs835a0405.Add(mem835a0405)

	var csignature_allocs *cgoAllocMap
	ref835a0405.signature, csignature_allocs = x.Signature.PassValue()
	allocs835a0405.Borrow(csignature_allocs)

	x.ref835a0405 = ref835a0405
	x.allocs835a0405 = allocs835a0405
	return ref835a0405, allocs835a0405

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilZeroSignatureResponse) PassValue() (C.fil_ZeroSignatureResponse, *cgoAllocMap) {
	if x.ref835a0405 != nil {
		return *x.ref835a0405, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilZeroSignatureResponse) Deref() {
	if x.ref835a0405 == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.ref835a0405.signature))
}

// allocFilGpuDeviceResponseMemory allocates memory for type C.fil_GpuDeviceResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGpuDeviceResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGpuDeviceResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilGpuDeviceResponseValue = unsafe.Sizeof([1]C.fil_GpuDeviceResponse{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGpuDeviceResponse) Ref() *C.fil_GpuDeviceResponse {
	if x == nil {
		return nil
	}
	return x.ref58f92915
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGpuDeviceResponse) Free() {
	if x != nil && x.allocs58f92915 != nil {
		x.allocs58f92915.(*cgoAllocMap).Free()
		x.ref58f92915 = nil
	}
}

// NewFilGpuDeviceResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGpuDeviceResponseRef(ref unsafe.Pointer) *FilGpuDeviceResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGpuDeviceResponse)
	obj.ref58f92915 = (*C.fil_GpuDeviceResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGpuDeviceResponse) PassRef() (*C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58f92915 != nil {
		return x.ref58f92915, nil
	}
	mem58f92915 := allocFilGpuDeviceResponseMemory(1)
	ref58f92915 := (*C.fil_GpuDeviceResponse)(mem58f92915)
	allocs58f92915 := new(cgoAllocMap)
	allocs58f92915.Add(mem58f92915)

	var cstatus_code_allocs *cgoAllocMap
	ref58f92915.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs58f92915.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref58f92915.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs58f92915.Borrow(cerror_msg_allocs)

	var cdevices_len_allocs *cgoAllocMap
	ref58f92915.devices_len, cdevices_len_allocs = (C.size_t)(x.DevicesLen), cgoAllocsUnknown
	allocs58f92915.Borrow(cdevices_len_allocs)

	var cdevices_ptr_allocs *cgoAllocMap
	ref58f92915.devices_ptr, cdevices_ptr_allocs = unpackSString(x.DevicesPtr)
	allocs58f92915.Borrow(cdevices_ptr_allocs)

	x.ref58f92915 = ref58f92915
	x.allocs58f92915 = allocs58f92915
	return ref58f92915, allocs58f92915

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGpuDeviceResponse) PassValue() (C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x.ref58f92915 != nil {
		return *x.ref58f92915, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGpuDeviceResponse) Deref() {
	if x.ref58f92915 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref58f92915.status_code)
	x.ErrorMsg = packPCharString(x.ref58f92915.error_msg)
	x.DevicesLen = (uint)(x.ref58f92915.devices_len)
	packSString(x.DevicesPtr, x.ref58f92915.devices_ptr)
}

// allocFilBLSDigestMemory allocates memory for type C.fil_BLSDigest in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSDigestValue = unsafe.Sizeof([1]C.fil_BLSDigest{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSDigest) Ref() *C.fil_BLSDigest {
	if x == nil {
		return nil
	}
	return x.ref215fc78c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSDigest) Free() {
	if x != nil && x.allocs215fc78c != nil {
		x.allocs215fc78c.(*cgoAllocMap).Free()
		x.ref215fc78c = nil
	}
}

// NewFilBLSDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSDigestRef(ref unsafe.Pointer) *FilBLSDigest {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSDigest)
	obj.ref215fc78c = (*C.fil_BLSDigest)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSDigest) PassRef() (*C.fil_BLSDigest, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref215fc78c != nil {
		return x.ref215fc78c, nil
	}
	mem215fc78c := allocFilBLSDigestMemory(1)
	ref215fc78c := (*C.fil_BLSDigest)(mem215fc78c)
	allocs215fc78c := new(cgoAllocMap)
	allocs215fc78c.Add(mem215fc78c)

	var cinner_allocs *cgoAllocMap
	ref215fc78c.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs215fc78c.Borrow(cinner_allocs)

	x.ref215fc78c = ref215fc78c
	x.allocs215fc78c = allocs215fc78c
	return ref215fc78c, allocs215fc78c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSDigest) PassValue() (C.fil_BLSDigest, *cgoAllocMap) {
	if x.ref215fc78c != nil {
		return *x.ref215fc78c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSDigest) Deref() {
	if x.ref215fc78c == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.ref215fc78c.inner))
}

// allocFilHashResponseMemory allocates memory for type C.fil_HashResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilHashResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilHashResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilHashResponseValue = unsafe.Sizeof([1]C.fil_HashResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilHashResponse) Ref() *C.fil_HashResponse {
	if x == nil {
		return nil
	}
	return x.refc52a22ef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilHashResponse) Free() {
	if x != nil && x.allocsc52a22ef != nil {
		x.allocsc52a22ef.(*cgoAllocMap).Free()
		x.refc52a22ef = nil
	}
}

// NewFilHashResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilHashResponseRef(ref unsafe.Pointer) *FilHashResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilHashResponse)
	obj.refc52a22ef = (*C.fil_HashResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilHashResponse) PassRef() (*C.fil_HashResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc52a22ef != nil {
		return x.refc52a22ef, nil
	}
	memc52a22ef := allocFilHashResponseMemory(1)
	refc52a22ef := (*C.fil_HashResponse)(memc52a22ef)
	allocsc52a22ef := new(cgoAllocMap)
	allocsc52a22ef.Add(memc52a22ef)

	var cdigest_allocs *cgoAllocMap
	refc52a22ef.digest, cdigest_allocs = x.Digest.PassValue()
	allocsc52a22ef.Borrow(cdigest_allocs)

	x.refc52a22ef = refc52a22ef
	x.allocsc52a22ef = allocsc52a22ef
	return refc52a22ef, allocsc52a22ef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilHashResponse) PassValue() (C.fil_HashResponse, *cgoAllocMap) {
	if x.refc52a22ef != nil {
		return *x.refc52a22ef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilHashResponse) Deref() {
	if x.refc52a22ef == nil {
		return
	}
	x.Digest = *NewFilBLSDigestRef(unsafe.Pointer(&x.refc52a22ef.digest))
}

// allocFilInitLogFdResponseMemory allocates memory for type C.fil_InitLogFdResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilInitLogFdResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilInitLogFdResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilInitLogFdResponseValue = unsafe.Sizeof([1]C.fil_InitLogFdResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilInitLogFdResponse) Ref() *C.fil_InitLogFdResponse {
	if x == nil {
		return nil
	}
	return x.ref3c1a0a08
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilInitLogFdResponse) Free() {
	if x != nil && x.allocs3c1a0a08 != nil {
		x.allocs3c1a0a08.(*cgoAllocMap).Free()
		x.ref3c1a0a08 = nil
	}
}

// NewFilInitLogFdResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilInitLogFdResponseRef(ref unsafe.Pointer) *FilInitLogFdResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilInitLogFdResponse)
	obj.ref3c1a0a08 = (*C.fil_InitLogFdResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilInitLogFdResponse) PassRef() (*C.fil_InitLogFdResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c1a0a08 != nil {
		return x.ref3c1a0a08, nil
	}
	mem3c1a0a08 := allocFilInitLogFdResponseMemory(1)
	ref3c1a0a08 := (*C.fil_InitLogFdResponse)(mem3c1a0a08)
	allocs3c1a0a08 := new(cgoAllocMap)
	allocs3c1a0a08.Add(mem3c1a0a08)

	var cstatus_code_allocs *cgoAllocMap
	ref3c1a0a08.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs3c1a0a08.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref3c1a0a08.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs3c1a0a08.Borrow(cerror_msg_allocs)

	x.ref3c1a0a08 = ref3c1a0a08
	x.allocs3c1a0a08 = allocs3c1a0a08
	return ref3c1a0a08, allocs3c1a0a08

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilInitLogFdResponse) PassValue() (C.fil_InitLogFdResponse, *cgoAllocMap) {
	if x.ref3c1a0a08 != nil {
		return *x.ref3c1a0a08, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilInitLogFdResponse) Deref() {
	if x.ref3c1a0a08 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref3c1a0a08.status_code)
	x.ErrorMsg = packPCharString(x.ref3c1a0a08.error_msg)
}

// allocFilBLSPrivateKeyMemory allocates memory for type C.fil_BLSPrivateKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPrivateKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPrivateKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSPrivateKeyValue = unsafe.Sizeof([1]C.fil_BLSPrivateKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPrivateKey) Ref() *C.fil_BLSPrivateKey {
	if x == nil {
		return nil
	}
	return x.ref2f77fe3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPrivateKey) Free() {
	if x != nil && x.allocs2f77fe3a != nil {
		x.allocs2f77fe3a.(*cgoAllocMap).Free()
		x.ref2f77fe3a = nil
	}
}

// NewFilBLSPrivateKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPrivateKeyRef(ref unsafe.Pointer) *FilBLSPrivateKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPrivateKey)
	obj.ref2f77fe3a = (*C.fil_BLSPrivateKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPrivateKey) PassRef() (*C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f77fe3a != nil {
		return x.ref2f77fe3a, nil
	}
	mem2f77fe3a := allocFilBLSPrivateKeyMemory(1)
	ref2f77fe3a := (*C.fil_BLSPrivateKey)(mem2f77fe3a)
	allocs2f77fe3a := new(cgoAllocMap)
	allocs2f77fe3a.Add(mem2f77fe3a)

	var cinner_allocs *cgoAllocMap
	ref2f77fe3a.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs2f77fe3a.Borrow(cinner_allocs)

	x.ref2f77fe3a = ref2f77fe3a
	x.allocs2f77fe3a = allocs2f77fe3a
	return ref2f77fe3a, allocs2f77fe3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPrivateKey) PassValue() (C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x.ref2f77fe3a != nil {
		return *x.ref2f77fe3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPrivateKey) Deref() {
	if x.ref2f77fe3a == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref2f77fe3a.inner))
}

// allocFilPrivateKeyGenerateResponseMemory allocates memory for type C.fil_PrivateKeyGenerateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyGenerateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyGenerateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeyGenerateResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyGenerateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyGenerateResponse) Ref() *C.fil_PrivateKeyGenerateResponse {
	if x == nil {
		return nil
	}
	return x.ref2dba09f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyGenerateResponse) Free() {
	if x != nil && x.allocs2dba09f != nil {
		x.allocs2dba09f.(*cgoAllocMap).Free()
		x.ref2dba09f = nil
	}
}

// NewFilPrivateKeyGenerateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyGenerateResponseRef(ref unsafe.Pointer) *FilPrivateKeyGenerateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyGenerateResponse)
	obj.ref2dba09f = (*C.fil_PrivateKeyGenerateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyGenerateResponse) PassRef() (*C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dba09f != nil {
		return x.ref2dba09f, nil
	}
	mem2dba09f := allocFilPrivateKeyGenerateResponseMemory(1)
	ref2dba09f := (*C.fil_PrivateKeyGenerateResponse)(mem2dba09f)
	allocs2dba09f := new(cgoAllocMap)
	allocs2dba09f.Add(mem2dba09f)

	var cprivate_key_allocs *cgoAllocMap
	ref2dba09f.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocs2dba09f.Borrow(cprivate_key_allocs)

	x.ref2dba09f = ref2dba09f
	x.allocs2dba09f = allocs2dba09f
	return ref2dba09f, allocs2dba09f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyGenerateResponse) PassValue() (C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x.ref2dba09f != nil {
		return *x.ref2dba09f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyGenerateResponse) Deref() {
	if x.ref2dba09f == nil {
		return
	}
	x.PrivateKey = *NewFilBLSPrivateKeyRef(unsafe.Pointer(&x.ref2dba09f.private_key))
}

// allocFilBLSPublicKeyMemory allocates memory for type C.fil_BLSPublicKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPublicKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPublicKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilBLSPublicKeyValue = unsafe.Sizeof([1]C.fil_BLSPublicKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPublicKey) Ref() *C.fil_BLSPublicKey {
	if x == nil {
		return nil
	}
	return x.ref6d0cab13
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPublicKey) Free() {
	if x != nil && x.allocs6d0cab13 != nil {
		x.allocs6d0cab13.(*cgoAllocMap).Free()
		x.ref6d0cab13 = nil
	}
}

// NewFilBLSPublicKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPublicKeyRef(ref unsafe.Pointer) *FilBLSPublicKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPublicKey)
	obj.ref6d0cab13 = (*C.fil_BLSPublicKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPublicKey) PassRef() (*C.fil_BLSPublicKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d0cab13 != nil {
		return x.ref6d0cab13, nil
	}
	mem6d0cab13 := allocFilBLSPublicKeyMemory(1)
	ref6d0cab13 := (*C.fil_BLSPublicKey)(mem6d0cab13)
	allocs6d0cab13 := new(cgoAllocMap)
	allocs6d0cab13.Add(mem6d0cab13)

	var cinner_allocs *cgoAllocMap
	ref6d0cab13.inner, cinner_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs6d0cab13.Borrow(cinner_allocs)

	x.ref6d0cab13 = ref6d0cab13
	x.allocs6d0cab13 = allocs6d0cab13
	return ref6d0cab13, allocs6d0cab13

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPublicKey) PassValue() (C.fil_BLSPublicKey, *cgoAllocMap) {
	if x.ref6d0cab13 != nil {
		return *x.ref6d0cab13, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPublicKey) Deref() {
	if x.ref6d0cab13 == nil {
		return
	}
	x.Inner = *(*[48]byte)(unsafe.Pointer(&x.ref6d0cab13.inner))
}

// allocFilPrivateKeyPublicKeyResponseMemory allocates memory for type C.fil_PrivateKeyPublicKeyResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyPublicKeyResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyPublicKeyResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeyPublicKeyResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyPublicKeyResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyPublicKeyResponse) Ref() *C.fil_PrivateKeyPublicKeyResponse {
	if x == nil {
		return nil
	}
	return x.refee14e59d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyPublicKeyResponse) Free() {
	if x != nil && x.allocsee14e59d != nil {
		x.allocsee14e59d.(*cgoAllocMap).Free()
		x.refee14e59d = nil
	}
}

// NewFilPrivateKeyPublicKeyResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyPublicKeyResponseRef(ref unsafe.Pointer) *FilPrivateKeyPublicKeyResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyPublicKeyResponse)
	obj.refee14e59d = (*C.fil_PrivateKeyPublicKeyResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyPublicKeyResponse) PassRef() (*C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee14e59d != nil {
		return x.refee14e59d, nil
	}
	memee14e59d := allocFilPrivateKeyPublicKeyResponseMemory(1)
	refee14e59d := (*C.fil_PrivateKeyPublicKeyResponse)(memee14e59d)
	allocsee14e59d := new(cgoAllocMap)
	allocsee14e59d.Add(memee14e59d)

	var cpublic_key_allocs *cgoAllocMap
	refee14e59d.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocsee14e59d.Borrow(cpublic_key_allocs)

	x.refee14e59d = refee14e59d
	x.allocsee14e59d = allocsee14e59d
	return refee14e59d, allocsee14e59d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyPublicKeyResponse) PassValue() (C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x.refee14e59d != nil {
		return *x.refee14e59d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyPublicKeyResponse) Deref() {
	if x.refee14e59d == nil {
		return
	}
	x.PublicKey = *NewFilBLSPublicKeyRef(unsafe.Pointer(&x.refee14e59d.public_key))
}

// allocFilPrivateKeySignResponseMemory allocates memory for type C.fil_PrivateKeySignResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeySignResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeySignResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFilPrivateKeySignResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeySignResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeySignResponse) Ref() *C.fil_PrivateKeySignResponse {
	if x == nil {
		return nil
	}
	return x.refcdf97b28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeySignResponse) Free() {
	if x != nil && x.allocscdf97b28 != nil {
		x.allocscdf97b28.(*cgoAllocMap).Free()
		x.refcdf97b28 = nil
	}
}

// NewFilPrivateKeySignResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeySignResponseRef(ref unsafe.Pointer) *FilPrivateKeySignResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeySignResponse)
	obj.refcdf97b28 = (*C.fil_PrivateKeySignResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeySignResponse) PassRef() (*C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdf97b28 != nil {
		return x.refcdf97b28, nil
	}
	memcdf97b28 := allocFilPrivateKeySignResponseMemory(1)
	refcdf97b28 := (*C.fil_PrivateKeySignResponse)(memcdf97b28)
	allocscdf97b28 := new(cgoAllocMap)
	allocscdf97b28.Add(memcdf97b28)

	var csignature_allocs *cgoAllocMap
	refcdf97b28.signature, csignature_allocs = x.Signature.PassValue()
	allocscdf97b28.Borrow(csignature_allocs)

	x.refcdf97b28 = refcdf97b28
	x.allocscdf97b28 = allocscdf97b28
	return refcdf97b28, allocscdf97b28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeySignResponse) PassValue() (C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x.refcdf97b28 != nil {
		return *x.refcdf97b28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeySignResponse) Deref() {
	if x.refcdf97b28 == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refcdf97b28.signature))
}

// allocFil32ByteArrayMemory allocates memory for type C.fil_32ByteArray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFil32ByteArrayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFil32ByteArrayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFil32ByteArrayValue = unsafe.Sizeof([1]C.fil_32ByteArray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fil32ByteArray) Ref() *C.fil_32ByteArray {
	if x == nil {
		return nil
	}
	return x.ref373ec61a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fil32ByteArray) Free() {
	if x != nil && x.allocs373ec61a != nil {
		x.allocs373ec61a.(*cgoAllocMap).Free()
		x.ref373ec61a = nil
	}
}

// NewFil32ByteArrayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFil32ByteArrayRef(ref unsafe.Pointer) *Fil32ByteArray {
	if ref == nil {
		return nil
	}
	obj := new(Fil32ByteArray)
	obj.ref373ec61a = (*C.fil_32ByteArray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fil32ByteArray) PassRef() (*C.fil_32ByteArray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref373ec61a != nil {
		return x.ref373ec61a, nil
	}
	mem373ec61a := allocFil32ByteArrayMemory(1)
	ref373ec61a := (*C.fil_32ByteArray)(mem373ec61a)
	allocs373ec61a := new(cgoAllocMap)
	allocs373ec61a.Add(mem373ec61a)

	var cinner_allocs *cgoAllocMap
	ref373ec61a.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs373ec61a.Borrow(cinner_allocs)

	x.ref373ec61a = ref373ec61a
	x.allocs373ec61a = allocs373ec61a
	return ref373ec61a, allocs373ec61a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fil32ByteArray) PassValue() (C.fil_32ByteArray, *cgoAllocMap) {
	if x.ref373ec61a != nil {
		return *x.ref373ec61a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fil32ByteArray) Deref() {
	if x.ref373ec61a == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref373ec61a.inner))
}

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})
